<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–î—Ä–µ–≤–æ –ñ–∏–∑–Ω–∏ ‚Äî –°–∏–º—É–ª—è—Ç–æ—Ä –†–æ—Å—Ç–∞</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: 'Segoe UI', 'Manrope', system-ui, -apple-system, sans-serif;
      background-color: #030712;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      overflow: hidden;
      color: #f5f7fb;
      background: radial-gradient(120% 120% at 50% 10%, #182244 0%, #050914 65%, #03040a 100%);
    }

      canvas {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: block;
        cursor: crosshair;
        touch-action: none;
        image-rendering: optimizeSpeed;
      }

    .hud {
      position: absolute;
      top: 32px;
      left: 64px;
      z-index: 2;
      max-width: 520px;
      backdrop-filter: blur(18px);
      background: rgba(5, 10, 21, 0.45);
      border: 1px solid rgba(182, 233, 255, 0.18);
      border-radius: 28px;
      padding: 28px 32px;
      box-shadow: 0 25px 60px rgba(8, 12, 32, 0.65);
    }

    .hud h1 {
      font-size: clamp(32px, 4vw, 44px);
      font-weight: 600;
      line-height: 1.2;
      margin-bottom: 12px;
      letter-spacing: -0.01em;
    }

    .hud p {
      font-size: 16px;
      line-height: 1.6;
      color: rgba(245, 247, 251, 0.85);
      margin-bottom: 20px;
    }

    .hud button {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 14px 24px;
      font-size: 15px;
      letter-spacing: 0.02em;
      border-radius: 999px;
      border: 1px solid rgba(181, 255, 217, 0.45);
      background: linear-gradient(120deg, rgba(141, 255, 195, 0.25), rgba(63, 192, 255, 0.2));
      color: #e6fff5;
      font-weight: 600;
      cursor: pointer;
      transition: transform 200ms ease, box-shadow 200ms ease, background 200ms ease;
    }

    .hud button:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 26px rgba(0, 255, 184, 0.25);
      background: linear-gradient(120deg, rgba(141, 255, 195, 0.35), rgba(63, 192, 255, 0.35));
    }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 12px;
    }

    .stat-card {
      min-width: 120px;
      padding: 12px 16px;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .stat-card span {
      display: block;
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 6px;
    }

    .stat-card strong {
      font-size: 18px;
      font-weight: 600;
    }

    .footer-note {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border-radius: 999px;
      background: rgba(4, 9, 22, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(18px);
      font-size: 15px;
      letter-spacing: 0.01em;
    }

    @media (max-width: 768px) {
      .hud {
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 32px);
      }

      .footer-note {
        width: calc(100% - 32px);
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <canvas id="treeCanvas"></canvas>

  <header class="hud">
    <h1>–í–∑—Ä–∞—Å—Ç–∏ —Å–≤–æ—ë –î—Ä–µ–≤–æ –ñ–∏–∑–Ω–∏</h1>
    <p>
      –ö–∞–∂–¥—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ —Å–∏–ª—ã –ø—Ä–∏—Ä–æ–¥—ã –¥–æ–±–∞–≤–ª—è—é—Ç –Ω–æ–≤—ã–µ –≤–µ—Ç–≤–∏, –ª–∏—Å—Ç—å—è –∏ –æ—Ç—Ç–µ–Ω–∫–∏. –ü–æ–ª–∏–≤–∞–π –¥–µ—Ä–µ–≤–æ, —á—Ç–æ–±—ã —É—Å–∫–æ—Ä–∏—Ç—å –µ–≥–æ —Ä–æ—Å—Ç,
      –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞—Å–ª–∞–∂–¥–∞–π—Å—è –º–µ–¥–∏—Ç–∞—Ü–∏–µ–π –∂–∏–≤–æ–π —ç–∫–æ—Å–∏—Å—Ç–µ–º—ã ‚Äî –≤—Å—ë —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä—è–º–æ –≤ –±—Ä–∞—É–∑–µ—Ä–µ, –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫.
    </p>
    <button id="waterBtn" type="button" aria-label="–ü–æ–ª–∏—Ç—å –¥–µ—Ä–µ–≤–æ">
      üíß –ü–æ–ª–∏—Ç—å –¥–µ—Ä–µ–≤–æ
    </button>

      <div class="stats">
        <div class="stat-card">
          <span>–í–æ–∑—Ä–∞—Å—Ç</span>
          <strong data-age>0.0 –ª–µ—Ç</strong>
        </div>
        <div class="stat-card">
          <span>–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ</span>
          <strong data-mood>–ì–ª—É–±–æ–∫–∏–π —Å–æ–Ω</strong>
        </div>
        <div class="stat-card">
          <span>–ü—Ä–æ–≥—Ä–µ—Å—Å —Ä–æ—Å—Ç–∞</span>
          <strong data-stage>0%</strong>
        </div>
        <div class="stat-card">
          <span>–ö–∞–¥—Ä–æ–≤–∞—è —á–∞—Å—Ç–æ—Ç–∞</span>
          <strong data-fps>0 FPS</strong>
        </div>
      </div>
  </header>

    <div class="footer-note" data-hint>
      –ü–æ–ª–∏–≤–∞–π –¥–µ—Ä–µ–≤–æ, —Å–ª–µ–¥–∏ –∑–∞ –ø—Ç–∏—Ü–∞–º–∏ –∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–æ–¥—Ä–µ–∑–∞–π –≤–µ—Ç–≤–∏ –ø–∏–ª–æ–π.
    </div>

  <script>
(() => {
  'use strict';

  const canvas = document.getElementById('treeCanvas');
  const ctx = canvas.getContext('2d');

  const ageEl = document.querySelector('[data-age]');
  const moodEl = document.querySelector('[data-mood]');
  const stageEl = document.querySelector('[data-stage]');
  const fpsEl = document.querySelector('[data-fps]');
  const hintEl = document.querySelector('[data-hint]');
  const waterBtn = document.getElementById('waterBtn');

  const CONFIG = {
    maxDepth: 7,
    growthDelayPerLevel: 0.11,
    baseGrowthSpeed: 0.00022,
    pulseBoost: 0.04,
    sawRadius: 28,
    sawCooldown: 140,
    fruitDepthStart: 4,
    saplingMin: 2,
    saplingMax: 4
  };

  const stageDescriptions = {
    seed: '–°–µ–º—è –Ω–∞–±–∏—Ä–∞–µ—Ç —Å–∏–ª—É',
    sprout: '–ú–æ–ª–æ–¥—ã–µ –ø–æ–±–µ–≥–∏',
    young: '–ì–∏–±–∫–æ–µ –¥–µ—Ä–µ–≤–æ',
    mature: '–ü—ã—à–Ω–∞—è –∫—Ä–æ–Ω–∞',
    fruit: '–°–æ–∑—Ä–µ–≤–∞–Ω–∏–µ –ø–ª–æ–¥–æ–≤',
    decline: '–û—Å–µ–Ω–Ω–∏–π –ª–∏—Å—Ç–æ–ø–∞–¥',
    seedFall: '–°–æ–Ω –∏ —Å–µ–º–µ–Ω–∞',
    rebirth: '–ù–æ–≤–æ–µ –ø–æ–∫–æ–ª–µ–Ω–∏–µ'
  };

  const stageHints = {
    seed: '–ü–æ–ª–µ–π —Å–µ–º—è –∏ –∂–¥–∏, –∫–∞–∫ –æ–Ω–æ —Ç—è–Ω–µ—Ç—Å—è –≤–≤–µ—Ä—Ö.',
    sprout: '–†–æ—Å—Ç –º–µ–¥–ª–µ–Ω–Ω—ã–π, –Ω–æ –∑–∞–º–µ—Ç–Ω—ã–π ‚Äî —Å–º–æ—Ç—Ä–∏ –∑–∞ –≤–µ—Ä—Ö—É—à–∫–æ–π.',
    young: '–í–µ—Ç–≤–∏ —Ä–µ–∞–≥–∏—Ä—É—é—Ç –Ω–∞ –≤–µ—Ç–µ—Ä, –º–æ–∂–Ω–æ –ø–æ–¥—Ä–µ–∑–∞—Ç—å –ª–∏—à–Ω–µ–µ –ø–∏–ª–æ–π.',
    mature: '–î–µ—Ä–µ–≤–æ –¥—ã—à–∏—Ç –ø–æ–ª–Ω–æ–π –∫—Ä–æ–Ω–æ–π ‚Äî —Å–ª–µ–¥–∏ –∑–∞ —Ñ–æ—Ä–º–æ–π.',
    fruit: '–ü–ª–æ–¥—ã –Ω–∞–ª–∏–≤–∞—é—Ç—Å—è —Å–æ–∫–æ–º, –¥–æ–∂–¥–∏—Å—å –∏—Ö —Å–≤–µ—á–µ–Ω–∏—è.',
    decline: '–ù–∞—Å—Ç—É–ø–∞–µ—Ç –æ—Å–µ–Ω—å, –ª–∏—Å—Ç—å—è —Ç–µ–ø–ª–µ—é—Ç –∏ –ø–∞–¥–∞—é—Ç.',
    seedFall: '–°–µ–º–µ–Ω–∞ —É–∫–æ—Ä–µ–Ω—è—é—Ç—Å—è, —Å–∫–æ—Ä–æ –≤–∑–æ–π–¥—É—Ç —Å–∞–∂–µ–Ω—Ü—ã.',
    rebirth: '–ú–æ–ª–æ–¥—ã–µ —Å–∞–∂–µ–Ω—Ü—ã –≥–æ—Ç–æ–≤—è—Ç –Ω–æ–≤—É—é –∂–∏–∑–Ω—å –¥–µ—Ä–µ–≤–∞.'
  };

  let width = 0;
  let height = 0;
  let tree = null;
  let branchIdCounter = 0;
  let growth = 0.015;
  let targetGrowth = 0.08;
  let hydration = 0;
  let lastTime = performance.now();
  let deltaMs = 16;
  let simulatedAge = 0;
  let wind = 0;
  let windTarget = 0;
  let season = Math.random() * Math.PI * 2;
  let fps = 60;
  let lifeStage = 'seed';
  let stageTimer = 0;
  let regenCountdown = 0;
  let fruitsRipened = 0;

  let branchSegments = [];
  let saplings = [];
  let sawdust = [];
  let sawTrail = [];
  let floatingLights = [];
  let mountains = [];
  let birds = [];
  let clouds = [];
  let stars = [];
  let rainDrops = [];
  let insects = [];
  let worms = [];
  let birdOnTree = null;
  
  // –ü–æ–≥–æ–¥–∞
  let weather = 'sunny'; // sunny, cloudy, rainy
  let weatherTimer = 0;
  let sunIntensity = 1;
  
  // –ó–≤—É–∫–∏
  let audioContext = null;
  let windGain = null;
  let birdsGain = null;
  let rainGain = null;
  let windSource = null;
  let rainSource = null;

  const sawState = { active: false, x: 0, y: 0, lastCut: 0 };

  const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
  const seededRandom = (seed) => (Math.sin(seed * 9341.13) + 1) / 2;

  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      windGain = audioContext.createGain();
      birdsGain = audioContext.createGain();
      rainGain = audioContext.createGain();
      
      windGain.connect(audioContext.destination);
      birdsGain.connect(audioContext.destination);
      rainGain.connect(audioContext.destination);
      
      windGain.gain.value = 0.15;
      birdsGain.gain.value = 0.12;
      rainGain.gain.value = 0;
      
      startWindSound();
      startBirdsSound();
    } catch (e) {
      console.log('Audio not available');
    }
  }
  
  function startWindSound() {
    if (!audioContext || !windGain || windSource) return;
    
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 2, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    
    const filter = audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 200;
    
    windSource = audioContext.createBufferSource();
    windSource.buffer = buffer;
    windSource.loop = true;
    windSource.connect(filter);
    filter.connect(windGain);
    windSource.start();
    
    // –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–µ—Ç—Ä–∞
    setInterval(() => {
      if (windGain) {
        windGain.gain.value = 0.1 + Math.abs(wind) * 0.2;
      }
    }, 100);
  }
  
  function startBirdsSound() {
    if (!audioContext || !birdsGain) return;
    
    function playBirdCall() {
      const baseFreq = 600 + Math.random() * 500;
      const duration = 0.2 + Math.random() * 0.4;
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.type = Math.random() > 0.5 ? 'sine' : 'triangle';
      oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
      
      // –°–æ–∑–¥–∞–µ–º –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –∑–≤—É–∫ –ø—Ç–∏—Ü—ã —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –Ω–æ—Ç–∞–º–∏
      const notes = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < notes; i++) {
        const noteTime = audioContext.currentTime + i * (duration / notes);
        const freq = baseFreq + (Math.random() - 0.5) * 200;
        oscillator.frequency.setValueAtTime(freq, noteTime);
      }
      
      oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 1.2, audioContext.currentTime + duration);
      
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.03);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.connect(gainNode);
      gainNode.connect(birdsGain);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –∏–≥—Ä–∞–µ–º –∑–≤—É–∫–∏ –ø—Ç–∏—Ü
    setInterval(() => {
      if (Math.random() < 0.4 && weather !== 'rainy') {
        playBirdCall();
        // –ò–Ω–æ–≥–¥–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ç–∏—Ü –ø–æ—é—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
        if (Math.random() < 0.3) {
          setTimeout(() => playBirdCall(), 200 + Math.random() * 400);
        }
      }
    }, 3000 + Math.random() * 4000);
  }

  function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    tree = buildTree();
    floatingLights = createFireflies(26);
    mountains = buildMountains();
    clouds = buildClouds();
    birds = createBirds(8);
    stars = createStars(110);
    sawState.x = width / 2;
    sawState.y = height / 2;
    
    if (!audioContext) {
      initAudio();
    }
  }

  window.addEventListener('resize', resize);
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  function initAudioOnInteraction() {
    if (!audioContext) {
      initAudio();
    }
    document.removeEventListener('click', initAudioOnInteraction);
    document.removeEventListener('touchstart', initAudioOnInteraction);
  }
  
  document.addEventListener('click', initAudioOnInteraction);
  document.addEventListener('touchstart', initAudioOnInteraction);
  
  resize();

  function buildTree() {
    branchIdCounter = 0;
    const baseLength = Math.min(width, height) * 0.25;
    return createBranch(0, baseLength, 0, Math.random() * 1000);
  }

  function createBranch(depth, length, angle, seed) {
    const branch = {
      id: branchIdCounter++,
      depth,
      length,
      angle,
      seed,
      children: [],
      swayPhase: Math.random() * Math.PI * 2,
      baseWidth: Math.max(1, (CONFIG.maxDepth - depth + 1) * 1.15),
      color: {
        r: 82 + depth * 5 + seededRandom(seed + 6) * 25,
        g: 58 + depth * 3 + seededRandom(seed + 7) * 18,
        b: 42 + depth * 2 + seededRandom(seed + 8) * 18
      },
      pruned: false,
      regrowAt: 0,
      pruneLength: length * (0.2 + seededRandom(seed + 12) * 0.2),
      fruits: null
    };

    if (depth >= CONFIG.maxDepth) {
      return branch;
    }

    const spread = 0.25 + seededRandom(seed + 1) * 0.35;
    const lenFactor = 0.68 + seededRandom(seed + 2) * 0.1 - depth * 0.01;
    const lean = (seededRandom(seed + 3) - 0.5) * 0.18;

    branch.children.push(
      createBranch(depth + 1, length * lenFactor, angle + spread + lean, seed * 1.71 + 1)
    );
    branch.children.push(
      createBranch(depth + 1, length * lenFactor, angle - spread + lean, seed * 1.71 + 2)
    );

    if (depth > 1 && seededRandom(seed + 4) > 0.58) {
      const variance = (seededRandom(seed + 5) - 0.5) * spread;
      branch.children.push(
        createBranch(depth + 1, length * (lenFactor * 0.9), angle + variance, seed * 1.71 + 3)
      );
    }

    return branch;
  }

  function createFireflies(count) {
    return Array.from({ length: count }).map(() => ({
      x: Math.random(),
      y: Math.random(),
      scale: 0.6 + Math.random() * 1.4,
      speed: 0.2 + Math.random() * 0.6,
      hue: 80 + Math.random() * 40,
      seed: Math.random() * 10
    }));
  }

  function createStars(count) {
    return Array.from({ length: count }).map(() => ({
      x: Math.random(),
      y: Math.random(),
      size: 0.5 + Math.random() * 1.5,
      speed: 0.0005 + Math.random() * 0.001,
      phase: Math.random() * Math.PI * 2
    }));
  }

  function buildMountains() {
    return Array.from({ length: 3 }).map((_, index) => {
      const offsetY = height * (0.45 + index * 0.08);
      const amplitude = 60 + index * 40;
      const segments = 16;
      const points = [];
      for (let i = 0; i <= segments; i += 1) {
        const t = i / segments;
        const x = t * width;
        const noise =
          Math.sin(t * Math.PI * 2 + index) * amplitude * 0.35 +
          Math.sin(t * 6 + index * 3) * amplitude * 0.15;
        const y = offsetY + noise;
        points.push({ x, y });
      }
      return {
        points,
        color: `rgba(${25 + index * 15}, ${40 + index * 18}, ${70 + index * 25}, ${0.35 + index * 0.15})`,
        parallax: 0.05 + index * 0.04,
        offset: Math.random() * 800
      };
    });
  }

  function buildClouds() {
    return Array.from({ length: 6 }).map(() => ({
      x: Math.random() * width,
      y: height * (0.08 + Math.random() * 0.2),
      speed: 10 + Math.random() * 25,
      scale: 0.6 + Math.random() * 1.2,
      opacity: 0.2 + Math.random() * 0.2
    }));
  }

  function createBirds(count) {
    return Array.from({ length: count }).map(() => spawnBird());
  }

  function spawnBird() {
    return {
      x: Math.random() * width,
      y: height * (0.15 + Math.random() * 0.35),
      speed: 35 + Math.random() * 45,
      direction: Math.random() > 0.5 ? 1 : -1,
      amplitude: 6 + Math.random() * 10,
      phase: Math.random() * Math.PI * 2,
      layer: 0.4 + Math.random() * 0.4
    };
  }

  function updateFireflies(delta) {
    floatingLights.forEach((light) => {
      light.y -= (light.speed * delta) / 8000;
      light.x += Math.sin(season + light.seed) * 0.0002 * delta;
      if (light.y < -0.05) {
        light.y = 1.1;
        light.x = Math.random();
      }
    });
  }

  function updateClouds(delta) {
    clouds.forEach((cloud) => {
      cloud.x += cloud.speed * delta * 0.0001;
      if (cloud.x > width + 200) {
        cloud.x = -200;
      }
    });
  }

  function updateBirds(delta) {
    birds.forEach((bird, idx) => {
      bird.phase += delta * 0.002;
      bird.x += bird.speed * bird.direction * delta * 0.0003;
      bird.y += Math.sin(bird.phase) * bird.amplitude * 0.02;
      if (bird.direction > 0 && bird.x > width + 40) {
        birds[idx] = spawnBird();
        birds[idx].x = -40;
        birds[idx].direction = 1;
      } else if (bird.direction < 0 && bird.x < -40) {
        birds[idx] = spawnBird();
        birds[idx].x = width + 40;
        birds[idx].direction = -1;
      }
    });
    
    // –ü—Ç–∏—Ü–∞ —Å–∞–¥–∏—Ç—Å—è –Ω–∞ –¥–µ—Ä–µ–≤–æ
    if (!birdOnTree && branchSegments.length > 0 && Math.random() < 0.0003) {
      const validSegments = branchSegments.filter(s => s.branch.depth > 2);
      if (validSegments.length > 0) {
        const segment = validSegments[Math.floor(Math.random() * validSegments.length)];
        birdOnTree = {
          x: (segment.x1 + segment.x2) / 2,
          y: (segment.y1 + segment.y2) / 2,
          branch: segment.branch,
          segment: segment,
          time: performance.now(),
          stayTime: 8000 + Math.random() * 12000,
          phase: Math.random() * Math.PI * 2
        };
      }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø—Ç–∏—Ü—ã –Ω–∞ –¥–µ—Ä–µ–≤–µ
    if (birdOnTree && birdOnTree.segment) {
      const segment = branchSegments.find(s => s.branch === birdOnTree.branch);
      if (segment) {
        birdOnTree.x = (segment.x1 + segment.x2) / 2;
        birdOnTree.y = (segment.y1 + segment.y2) / 2;
        birdOnTree.segment = segment;
      }
    }
    
    // –ü—Ç–∏—Ü–∞ —É–ª–µ—Ç–∞–µ—Ç
    if (birdOnTree && performance.now() - birdOnTree.time > birdOnTree.stayTime) {
      birdOnTree = null;
    }
  }
  
  function spawnInsect() {
    return {
      x: Math.random() * width,
      y: height - 50 + Math.random() * 30,
      targetX: Math.random() * width,
      targetY: height * (0.3 + Math.random() * 0.4),
      speed: 0.3 + Math.random() * 0.5,
      size: 1.5 + Math.random() * 2,
      type: Math.random() > 0.5 ? 'fly' : 'bee',
      life: 1,
      phase: Math.random() * Math.PI * 2
    };
  }
  
  function updateInsects(delta) {
    if (insects.length < 3 && Math.random() < 0.001) {
      insects.push(spawnInsect());
    }
    
    insects = insects.filter((insect) => {
      const dx = insect.targetX - insect.x;
      const dy = insect.targetY - insect.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist < 5) {
        insect.targetX = Math.random() * width;
        insect.targetY = height * (0.3 + Math.random() * 0.4);
      }
      
      insect.x += (dx / dist) * insect.speed * delta * 0.01;
      insect.y += (dy / dist) * insect.speed * delta * 0.01;
      insect.phase += delta * 0.01;
      insect.life -= delta * 0.0001;
      
      return insect.life > 0 && insect.y > 0;
    });
  }
  
  function spawnWorm() {
    const groundY = height - 40;
    return {
      x: width * (0.3 + Math.random() * 0.4),
      y: groundY + Math.random() * 5,
      progress: 0,
      length: 8 + Math.random() * 6,
      speed: 0.0001 + Math.random() * 0.0002,
      direction: Math.random() > 0.5 ? 1 : -1,
      life: 1,
      phase: Math.random() * Math.PI * 2
    };
  }
  
  function updateWorms(delta) {
    if (worms.length < 2 && Math.random() < 0.0005) {
      worms.push(spawnWorm());
    }
    
    worms = worms.filter((worm) => {
      worm.x += worm.speed * worm.direction * delta;
      worm.progress += delta * 0.0001;
      worm.phase += delta * 0.002;
      
      if (worm.x < width * 0.2 || worm.x > width * 0.8) {
        worm.direction *= -1;
      }
      
      worm.life -= delta * 0.00005;
      return worm.life > 0;
    });
  }
  
  function updateWeather(delta) {
    weatherTimer += delta;
    
    // –°–º–µ–Ω–∞ –ø–æ–≥–æ–¥—ã –∫–∞–∂–¥—ã–µ 20-40 —Å–µ–∫—É–Ω–¥
    if (weatherTimer > 20000 + Math.random() * 20000) {
      const weathers = ['sunny', 'cloudy', 'rainy'];
      const currentIndex = weathers.indexOf(weather);
      let nextIndex = Math.floor(Math.random() * weathers.length);
      if (nextIndex === currentIndex) {
        nextIndex = (nextIndex + 1) % weathers.length;
      }
      weather = weathers[nextIndex];
      weatherTimer = 0;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –∑–≤—É–∫ –¥–æ–∂–¥—è
      if (rainGain) {
        if (weather === 'rainy') {
          if (!rainSource) {
            startRainSound();
          }
          rainGain.gain.value = 0.2;
        } else {
          stopRainSound();
          rainGain.gain.value = 0;
        }
      }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Å–æ–ª–Ω—Ü–∞
    if (weather === 'sunny') {
      sunIntensity = 0.8 + Math.sin(weatherTimer * 0.0001) * 0.2;
    } else if (weather === 'cloudy') {
      sunIntensity = 0.4 + Math.sin(weatherTimer * 0.0001) * 0.2;
    } else {
      sunIntensity = 0.2;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–ø–ª–∏ –¥–æ–∂–¥—è
    if (weather === 'rainy') {
      if (rainDrops.length < 150) {
        for (let i = 0; i < 3; i++) {
          rainDrops.push({
            x: Math.random() * width,
            y: -10,
            speed: 0.3 + Math.random() * 0.4,
            length: 8 + Math.random() * 12
          });
        }
      }
      
      rainDrops = rainDrops.filter((drop) => {
        drop.y += drop.speed * delta * 0.5;
        return drop.y < height + 20;
      });
    } else {
      rainDrops = [];
    }
  }
  
  function startRainSound() {
    if (!audioContext || !rainGain || rainSource) return;
    
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
      data[i] = (Math.random() * 2 - 1) * 0.3;
    }
    
    const filter = audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 1000;
    
    rainSource = audioContext.createBufferSource();
    rainSource.buffer = buffer;
    rainSource.loop = true;
    rainSource.connect(filter);
    filter.connect(rainGain);
    rainSource.start();
  }
  
  function stopRainSound() {
    if (rainSource) {
      try {
        rainSource.stop();
      } catch (e) {}
      rainSource = null;
    }
  }

  function updateSaplings(delta) {
    saplings.forEach((sapling) => {
      sapling.growth = clamp(sapling.growth + delta * 0.00012, 0, 1);
      sapling.phase += delta * 0.001;
    });
  }

  function drawSaplings(time) {
    saplings.forEach((sapling) => {
      const swayOffset = Math.sin(time * 0.001 + sapling.phase) * sapling.sway;
      const heightScale = sapling.growth * 40;
      ctx.strokeStyle = 'rgba(92, 140, 92, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sapling.x, sapling.y);
      ctx.quadraticCurveTo(
        sapling.x + swayOffset,
        sapling.y - heightScale * 0.5,
        sapling.x + swayOffset * 1.2,
        sapling.y - heightScale
      );
      ctx.stroke();
      ctx.fillStyle = 'rgba(122, 200, 122, 0.6)';
      ctx.beginPath();
      ctx.arc(sapling.x + swayOffset * 1.2, sapling.y - heightScale, 4 + sapling.growth * 3, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function spawnSaplings() {
    const fruitBonus = Math.min(3, Math.floor(fruitsRipened / 6));
    const randomCount =
      CONFIG.saplingMin + Math.random() * (CONFIG.saplingMax - CONFIG.saplingMin + 1);
    const count = Math.max(CONFIG.saplingMin, Math.floor(randomCount + fruitBonus));
    fruitsRipened = Math.max(0, fruitsRipened - fruitBonus * 3);
    saplings = Array.from({ length: count }).map(() => ({
      x: width / 2 + (Math.random() - 0.5) * width * 0.18,
      y: height - 45 + Math.random() * 10,
      growth: 0.02,
      phase: Math.random() * Math.PI * 2,
      sway: 0.4 + Math.random() * 0.6
    }));
  }

  function setStage(nextStage) {
    if (lifeStage === nextStage) {
      return;
    }
    lifeStage = nextStage;
    stageTimer = 0;
  }

  function updateLifeStage(delta) {
    switch (lifeStage) {
      case 'seed':
        if (growth > 0.18) setStage('sprout');
        break;
      case 'sprout':
        if (growth > 0.42) setStage('young');
        break;
      case 'young':
        if (growth > 0.66) setStage('mature');
        break;
      case 'mature':
        if (growth > 0.82 && stageTimer > 6000) setStage('fruit');
        break;
      case 'fruit':
        if (stageTimer > 32000 || Math.random() < delta * 0.0000006) {
          setStage('decline');
        }
        break;
      case 'decline':
        if (growth < 0.3) {
          setStage('seedFall');
        }
        break;
      case 'seedFall':
        regenCountdown += delta;
        if (!saplings.length) {
          spawnSaplings();
        }
        if (regenCountdown > 18000) {
          setStage('rebirth');
        }
        break;
      case 'rebirth':
        if (!saplings.length) {
          spawnSaplings();
        }
        if (saplings.every((sapling) => sapling.growth > 0.98)) {
          tree = buildTree();
          growth = 0.05;
          targetGrowth = 0.15;
          saplings = [];
          setStage('sprout');
        }
        break;
      default:
        break;
    }

    if (lifeStage !== 'seedFall' && lifeStage !== 'rebirth') {
      regenCountdown = 0;
    }

    if (lifeStage === 'decline') {
      targetGrowth = Math.max(0.24, targetGrowth - delta * 0.00012);
    }
  }

  function drawSky(time) {
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    let dawn = 0.2 + Math.sin(season * 0.6) * 0.1;
    
    // –í–ª–∏—è–Ω–∏–µ –ø–æ–≥–æ–¥—ã –Ω–∞ —Ü–≤–µ—Ç –Ω–µ–±–∞
    if (weather === 'rainy') {
      dawn *= 0.5;
    } else if (weather === 'cloudy') {
      dawn *= 0.7;
    }
    
    gradient.addColorStop(0, `rgba(${20 + dawn * 120}, ${40 + dawn * 80}, ${110 + dawn * 50}, 1)`);
    gradient.addColorStop(0.55, '#09152f');
    gradient.addColorStop(1, '#030711');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // –°–æ–ª–Ω—Ü–µ
    if (weather === 'sunny' || weather === 'cloudy') {
      const sunX = width * 0.8;
      const sunY = height * 0.15;
      const sunRadius = 40 * sunIntensity;
      
      const sunGradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius * 2);
      sunGradient.addColorStop(0, `rgba(255, 255, 200, ${0.8 * sunIntensity})`);
      sunGradient.addColorStop(0.5, `rgba(255, 220, 150, ${0.4 * sunIntensity})`);
      sunGradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
      
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius * 2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = `rgba(255, 255, 180, ${0.9 * sunIntensity})`;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();
    }

    stars.forEach((star) => {
      const twinkle = 0.5 + Math.sin(time * star.speed + star.phase) * 0.4;
      const opacity = weather === 'rainy' ? 0 : (0.15 + twinkle * 0.2);
      ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.fillRect(star.x * width, star.y * height * 0.5, star.size, star.size);
    });
  }
  
  function drawRain() {
    if (weather !== 'rainy') return;
    
    ctx.strokeStyle = 'rgba(150, 180, 255, 0.6)';
    ctx.lineWidth = 1.5;
    
    rainDrops.forEach((drop) => {
      ctx.beginPath();
      ctx.moveTo(drop.x, drop.y);
      ctx.lineTo(drop.x, drop.y + drop.length);
      ctx.stroke();
    });
  }
  
  function drawBirdOnTree(time) {
    if (!birdOnTree) return;
    
    const sway = Math.sin(time * 0.001 + birdOnTree.phase) * 2;
    ctx.save();
    ctx.translate(birdOnTree.x + sway, birdOnTree.y);
    ctx.fillStyle = 'rgba(100, 80, 60, 0.9)';
    ctx.beginPath();
    ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // –ö–ª—é–≤
    ctx.fillStyle = 'rgba(255, 150, 0, 0.9)';
    ctx.beginPath();
    ctx.moveTo(4, 0);
    ctx.lineTo(8, -2);
    ctx.lineTo(8, 2);
    ctx.closePath();
    ctx.fill();
    
    // –ì–ª–∞–∑
    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
    ctx.beginPath();
    ctx.arc(-2, -1, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(0, 0, 0, 1)';
    ctx.beginPath();
    ctx.arc(-2, -1, 0.8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
  
  function drawInsects(time) {
    insects.forEach((insect) => {
      ctx.save();
      ctx.translate(insect.x, insect.y);
      
      if (insect.type === 'bee') {
        // –ü—á–µ–ª–∞
        ctx.fillStyle = `rgba(255, 200, 0, ${insect.life * 0.8})`;
        ctx.beginPath();
        ctx.ellipse(0, 0, insect.size * 1.5, insect.size, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // –ü–æ–ª–æ—Å–∫–∏
        ctx.strokeStyle = `rgba(0, 0, 0, ${insect.life * 0.6})`;
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(-insect.size, 0);
        ctx.lineTo(insect.size, 0);
        ctx.stroke();
      } else {
        // –ú—É—Ö–∞
        ctx.fillStyle = `rgba(50, 50, 50, ${insect.life * 0.7})`;
        ctx.beginPath();
        ctx.ellipse(0, 0, insect.size, insect.size * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // –ö—Ä—ã–ª—å—è
      const wingOffset = Math.sin(insect.phase * 5) * 2;
      ctx.fillStyle = `rgba(200, 200, 255, ${insect.life * 0.3})`;
      ctx.beginPath();
      ctx.ellipse(-insect.size * 0.5, wingOffset, insect.size * 0.8, insect.size * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(insect.size * 0.5, -wingOffset, insect.size * 0.8, insect.size * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
  }
  
  function drawWorms(time) {
    worms.forEach((worm) => {
      const segments = 5;
      const segmentLength = worm.length / segments;
      
      ctx.strokeStyle = `rgba(139, 90, 43, ${worm.life * 0.8})`;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      
      ctx.beginPath();
      let prevX = worm.x;
      let prevY = worm.y;
      
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const offsetX = Math.sin(worm.phase + t * Math.PI * 2) * 1.5;
        const offsetY = Math.cos(worm.phase + t * Math.PI * 2) * 0.5;
        const x = worm.x + (i * segmentLength * worm.direction) + offsetX;
        const y = worm.y + offsetY;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        
        prevX = x;
        prevY = y;
      }
      
      ctx.stroke();
      
      // –ì–æ–ª–æ–≤–∞ —á–µ—Ä–≤—è–∫–∞
      ctx.fillStyle = `rgba(160, 100, 50, ${worm.life * 0.9})`;
      ctx.beginPath();
      ctx.arc(worm.x + (segments * segmentLength * worm.direction), worm.y, 2, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawMountains(time) {
    mountains.forEach((layer, index) => {
      ctx.fillStyle = layer.color;
      ctx.beginPath();
      ctx.moveTo(0, height);
      layer.points.forEach((point, idx) => {
        const wave = Math.sin(time * 0.00002 + idx * 0.5 + layer.offset) * 8 * (index + 1) * 0.2;
        ctx.lineTo(point.x, point.y + wave);
      });
      ctx.lineTo(width, height);
      ctx.closePath();
      ctx.fill();
    });
  }

  function drawCloudsLayer() {
    const weatherMultiplier = weather === 'rainy' ? 1.5 : weather === 'cloudy' ? 1.2 : 0.8;
    
    clouds.forEach((cloud) => {
      const opacity = cloud.opacity * weatherMultiplier;
      const color = weather === 'rainy' ? 'rgba(150, 170, 200' : 'rgba(210, 230, 255';
      ctx.fillStyle = `${color}, ${Math.min(1, opacity)})`;
      ctx.beginPath();
      ctx.ellipse(cloud.x, cloud.y, 120 * cloud.scale, 40 * cloud.scale, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–ª–æ–∏ –¥–ª—è –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã—Ö –æ–±–ª–∞–∫–æ–≤
      if (weather === 'cloudy' || weather === 'rainy') {
        ctx.fillStyle = `${color}, ${Math.min(0.6, opacity * 0.7)})`;
        ctx.beginPath();
        ctx.ellipse(cloud.x - 40 * cloud.scale, cloud.y, 80 * cloud.scale, 30 * cloud.scale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cloud.x + 40 * cloud.scale, cloud.y, 80 * cloud.scale, 30 * cloud.scale, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  function drawFirefliesLayer() {
    floatingLights.forEach((light) => {
      const x = light.x * width;
      const y = light.y * height;
      ctx.beginPath();
      ctx.fillStyle = `hsla(${light.hue}, 80%, 70%, 0.35)`;
      ctx.arc(x, y, light.scale * 2.2, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawBirdsLayer(time) {
    birds.forEach((bird) => {
      ctx.save();
      ctx.translate(bird.x, bird.y + Math.sin(time * 0.001 + bird.phase) * bird.amplitude);
      ctx.scale(bird.direction, 1);
      ctx.strokeStyle = `rgba(255, 255, 255, ${0.25 + bird.layer * 0.25})`;
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(-8, 0);
      ctx.quadraticCurveTo(0, -4, 8, 0);
      ctx.stroke();
      ctx.restore();
    });
  }

  function drawGround() {
    ctx.save();
    ctx.translate(width / 2, height - 35);
    const grd = ctx.createRadialGradient(0, 0, 40, 0, 0, Math.max(width, 500));
    grd.addColorStop(0, 'rgba(34, 70, 38, 0.8)');
    grd.addColorStop(0.6, 'rgba(14, 32, 24, 0.95)');
    grd.addColorStop(1, 'rgba(4, 8, 12, 1)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.ellipse(0, 0, width * 0.55, 190, 0, 0, Math.PI, true);
    ctx.fill();
    ctx.restore();
  }

  function drawTree(time) {
    if (!tree) return;
    branchSegments.length = 0;
    drawBranch(tree, time, 0, width / 2, height - 60);
  }

  function drawBranch(branch, time, parentAngle, startX, startY) {
    const depthDelay = branch.depth * CONFIG.growthDelayPerLevel;
    const available = 1 - depthDelay;
    const progress = clamp((growth - depthDelay) / available, 0, 1);

    if (progress <= 0) {
      return;
    }

    const eased = easeOutCubic(progress);
    const sway =
      Math.sin(time * 0.0009 + branch.swayPhase + branch.seed) *
      (0.03 + (CONFIG.maxDepth - branch.depth) * 0.005) *
      (0.35 + growth * 0.65);
    const windGust = wind * (0.25 + branch.depth * 0.04);
    const angle = parentAngle + branch.angle + sway + windGust;
    const length = branch.length * eased;
    const dryness = lifeStage === 'decline' || lifeStage === 'seedFall' ? 0.72 : 1;
    const endX = startX + Math.sin(angle) * length;
    const endY = startY - Math.cos(angle) * length;

    if (branch.pruned) {
      if (time > branch.regrowAt) {
        branch.pruned = false;
      } else {
        const stubLength = Math.min(branch.pruneLength, length * 0.6);
        const stubX = startX + Math.sin(angle) * stubLength;
        const stubY = startY - Math.cos(angle) * stubLength;
        ctx.strokeStyle = 'rgba(74, 58, 46, 0.95)';
        ctx.lineWidth = branch.baseWidth;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(stubX, stubY);
        ctx.stroke();
        ctx.fillStyle = 'rgba(190, 150, 110, 0.9)';
        ctx.beginPath();
        ctx.arc(stubX, stubY, branch.baseWidth * 0.45, 0, Math.PI * 2);
        ctx.fill();
        return;
      }
    }

    // –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π —Ä–æ—Å—Ç: —Ä–∏—Å—É–µ–º –≤–µ—Ç–∫—É —Å–µ–≥–º–µ–Ω—Ç –∑–∞ —Å–µ–≥–º–µ–Ω—Ç–æ–º
    if (!branch.growthSegments) {
      branch.growthSegments = 8 + Math.floor(branch.length / 15);
      branch.segmentProgress = 0;
    }
    
    const segmentLength = length / branch.growthSegments;
    const segmentsToDraw = Math.floor(branch.growthSegments * eased);
    const partialSegment = (branch.growthSegments * eased) - segmentsToDraw;
    
    ctx.strokeStyle = `rgba(${(branch.color.r * dryness).toFixed(0)}, ${(branch.color.g * dryness).toFixed(0)}, ${(branch.color.b * dryness).toFixed(0)}, ${0.82 - branch.depth * 0.04})`;
    ctx.lineWidth = branch.baseWidth * (0.8 + 0.2 * (1 - progress));
    
    let currentX = startX;
    let currentY = startY;
    let currentAngle = angle;
    
    // –†–∏—Å—É–µ–º –ø–æ–ª–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã
    for (let i = 0; i < segmentsToDraw; i++) {
      const nextX = currentX + Math.sin(currentAngle) * segmentLength;
      const nextY = currentY - Math.cos(currentAngle) * segmentLength;
      
      ctx.beginPath();
      ctx.moveTo(currentX, currentY);
      ctx.lineTo(nextX, nextY);
      ctx.stroke();
      
      currentX = nextX;
      currentY = nextY;
    }
    
    // –†–∏—Å—É–µ–º —á–∞—Å—Ç–∏—á–Ω—ã–π —Å–µ–≥–º–µ–Ω—Ç (—Ä–∞—Å—Ç—É—â–∏–π –∫–æ–Ω—á–∏–∫)
    if (partialSegment > 0 && segmentsToDraw < branch.growthSegments) {
      const tipX = currentX + Math.sin(currentAngle) * segmentLength * partialSegment;
      const tipY = currentY - Math.cos(currentAngle) * segmentLength * partialSegment;
      
      ctx.beginPath();
      ctx.moveTo(currentX, currentY);
      ctx.lineTo(tipX, tipY);
      ctx.stroke();
      
      // –†–∏—Å—É–µ–º —Ä–∞—Å—Ç—É—â–∏–π –∫–æ–Ω—á–∏–∫
      ctx.fillStyle = `rgba(182, 255, 222, ${0.6 * partialSegment})`;
      ctx.beginPath();
      ctx.arc(tipX, tipY, 2 + branch.baseWidth * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      currentX = tipX;
      currentY = tipY;
    }
    
    const finalEndX = startX + Math.sin(angle) * length;
    const finalEndY = startY - Math.cos(angle) * length;
    branchSegments.push({ branch, x1: startX, y1: startY, x2: finalEndX, y2: finalEndY });

    if (branch.children.length === 0 && progress > 0.35) {
      drawLeaf(finalEndX, finalEndY, angle, branch, time);
      if (branch.depth >= CONFIG.fruitDepthStart) {
        drawFruit(finalEndX, finalEndY, branch, angle, time);
      }
    } else if (progress > 0.55) {
      branch.children.forEach((child) => drawBranch(child, time, angle, finalEndX, finalEndY));
    } else if (progress > 0.1) {
      drawBud(finalEndX, finalEndY, branch);
    }
  }

  function drawLeaf(x, y, angle, branch, time) {
    const seasonalShift = Math.sin(season + branch.seed * 3);
    const declineShift = lifeStage === 'decline' || lifeStage === 'seedFall' ? 35 : 0;
    const hue = clamp(110 + seasonalShift * 25 - declineShift, 35, 140);
    const lightness = 45 + Math.cos(season * 0.5 + branch.seed * 11) * 12;
    const length = 11 + (1 - branch.depth / CONFIG.maxDepth) * 6;
    const widthLeaf = 4 + (1 - branch.depth / CONFIG.maxDepth) * 2;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle + Math.sin(time * 0.003 + branch.seed * 10) * 0.4);
    ctx.fillStyle = `hsla(${hue}, 65%, ${lightness}%, ${0.85 - 0.25 * (1 - growth)})`;
    ctx.beginPath();
    ctx.ellipse(0, 0, widthLeaf, length, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawBud(x, y, branch) {
    ctx.fillStyle = 'rgba(182, 255, 222, 0.45)';
    ctx.beginPath();
    ctx.arc(x, y, 3 + branch.depth * 0.2, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawFruit(x, y, branch, angle, time) {
    if (lifeStage !== 'fruit' && lifeStage !== 'decline' && lifeStage !== 'seedFall') {
      return;
    }

    if (!branch.fruits) {
      const count = seededRandom(branch.seed + 40) > 0.65 ? 2 : 1;
      branch.fruits = Array.from({ length: count }).map((_, idx) => ({
        offset: (idx === 0 ? -1 : 1) * (0.5 + seededRandom(branch.seed + idx) * 0.3),
        angleOffset: (idx === 0 ? -0.4 : 0.4) + (seededRandom(branch.seed + idx + 1) - 0.5) * 0.3,
        ripeness: 0.1 + Math.random() * 0.2,
        counted: false
      }));
    }

    branch.fruits.forEach((fruit) => {
      fruit.ripeness = clamp(fruit.ripeness + deltaMs * 0.00005 + hydration * 0.0001, 0, 1.2);
      if (fruit.ripeness > 0.98 && !fruit.counted) {
        fruitsRipened += 1;
        fruit.counted = true;
      }
      const swing = Math.sin(time * 0.003 + branch.seed * 14 + fruit.offset) * 4;
      const distance = 12 + fruit.ripeness * 6;
      const fruitX = x + Math.cos(angle + fruit.angleOffset) * distance * fruit.offset + swing;
      const fruitY = y + Math.sin(angle + fruit.angleOffset) * distance * 0.4 + 8;
      const radius = 4 + fruit.ripeness * 4;
      const hue = clamp(28 + fruit.ripeness * 60, 25, 90);
      ctx.fillStyle = `hsla(${hue}, 75%, ${55 - fruit.ripeness * 8}%, 0.9)`;
      ctx.beginPath();
      ctx.ellipse(fruitX, fruitY, radius * 0.8, radius, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
      ctx.beginPath();
      ctx.arc(fruitX - radius * 0.2, fruitY - radius * 0.4, radius * 0.25, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function pointerToCanvas(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = ((evt.clientX - rect.left) / rect.width) * canvas.width;
    const y = ((evt.clientY - rect.top) / rect.height) * canvas.height;
    return { x, y };
  }

  function updatePointer(point) {
    sawState.x = point.x;
    sawState.y = point.y;
    if (sawState.active) {
      sawTrail.push({ x: point.x, y: point.y, life: 1 });
      if (sawTrail.length > 60) {
        sawTrail.shift();
      }
    }
  }

  function closestPoint(x1, y1, x2, y2, px, py) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lenSq = dx * dx + dy * dy || 1;
    const t = clamp(((px - x1) * dx + (py - y1) * dy) / lenSq, 0, 1);
    return { x: x1 + dx * t, y: y1 + dy * t };
  }

  function spawnSawdust(point) {
    for (let i = 0; i < 12; i += 1) {
      sawdust.push({
        x: point.x,
        y: point.y,
        vx: (Math.random() - 0.5) * 0.35,
        vy: -0.2 - Math.random() * 0.3,
        life: 1
      });
    }
  }

  function performSawCut() {
    if (!branchSegments.length) return;
    const now = performance.now();
    if (now - sawState.lastCut < CONFIG.sawCooldown) return;

    let chosen = null;
    let bestDist = CONFIG.sawRadius;
    let chosenPoint = null;

    branchSegments.forEach((segment) => {
      if (segment.branch.depth === 0 || segment.branch.pruned) {
        return;
      }
      const point = closestPoint(segment.x1, segment.y1, segment.x2, segment.y2, sawState.x, sawState.y);
      const dist = Math.hypot(point.x - sawState.x, point.y - sawState.y);
      if (dist < bestDist) {
        bestDist = dist;
        chosen = segment;
        chosenPoint = point;
      }
    });

    if (chosen && chosenPoint) {
      chosen.branch.pruned = true;
      chosen.branch.regrowAt = now + 18000 + Math.random() * 14000;
      sawState.lastCut = now;
      spawnSawdust(chosenPoint);
      hintEl.textContent = '–í–µ—Ç–∫–∞ —É–±—Ä–∞–Ω–∞ ‚Äî –∂–¥–∏, –ø–æ–∫–∞ –≤—ã—Ä–∞—Å—Ç–µ—Ç —Å–≤–µ–∂–∞—è –ø–æ—á–∫–∞.';
    }
  }

  function updateSawdust(delta) {
    sawdust = sawdust.filter((particle) => {
      particle.vy += 0.0004 * delta;
      particle.x += particle.vx * delta * 0.6;
      particle.y += particle.vy * delta * 0.6;
      particle.life -= delta * 0.0016;
      return particle.life > 0;
    });
  }

  function updateSawTrail(delta) {
    sawTrail = sawTrail
      .map((point) => ({ ...point, life: point.life - delta * 0.0028 }))
      .filter((point) => point.life > 0);
  }

  function drawSawOverlay() {
    sawdust.forEach((particle) => {
      ctx.fillStyle = `rgba(216, 198, 150, ${particle.life * 0.7})`;
      ctx.fillRect(particle.x, particle.y, 2, 2);
    });

    sawTrail.forEach((trailPoint) => {
      ctx.beginPath();
      ctx.fillStyle = `rgba(199, 255, 210, ${trailPoint.life * 0.5})`;
      ctx.arc(trailPoint.x, trailPoint.y, 6 * trailPoint.life, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.save();
    ctx.strokeStyle = sawState.active ? 'rgba(199, 255, 210, 0.9)' : 'rgba(199, 255, 210, 0.4)';
    ctx.lineWidth = sawState.active ? 2 : 1;
    ctx.beginPath();
    ctx.arc(sawState.x, sawState.y, CONFIG.sawRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  function updateHud() {
    ageEl.textContent = `${(simulatedAge / 2 + growth * 10).toFixed(1)} –ª–µ—Ç`;
    moodEl.textContent = stageDescriptions[lifeStage] || '–ù–∞–±–ª—é–¥–µ–Ω–∏–µ';
    stageEl.textContent = `${Math.round(clamp(growth, 0, 1) * 100)}%`;
    fpsEl.textContent = `${Math.round(fps)} FPS`;
    if (sawState.active) {
      hintEl.textContent = '–ü–∏–ª–∞ –∞–∫—Ç–∏–≤–Ω–∞ ‚Äî –æ—Ç–ø—É—Å—Ç–∏ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –≤–Ω–æ–≤—å –Ω–∞–±–ª—é–¥–∞—Ç—å.';
    } else {
      hintEl.textContent = stageHints[lifeStage] || '–ü–æ–ª–µ–π –¥–µ—Ä–µ–≤–æ, —á—Ç–æ–±—ã —É—Å–∫–æ—Ä–∏—Ç—å —Ä–æ—Å—Ç.';
    }
  }

  function scheduleGrowthPulse() {
    const nextPulse = 3500 + Math.random() * 3500;
    setTimeout(() => {
      const maturityBonus =
        lifeStage === 'fruit' ? 1 : lifeStage === 'mature' ? 0.7 : lifeStage === 'seed' ? 1.2 : 0.5;
      targetGrowth = clamp(
        targetGrowth + CONFIG.pulseBoost * (0.4 + Math.random() * maturityBonus),
        0,
        1.08
      );
      simulatedAge += 0.4 + Math.random() * 0.7;
      scheduleGrowthPulse();
    }, nextPulse);
  }

  waterBtn.addEventListener('click', () => {
    hydration = Math.min(1.5, hydration + 0.9);
    targetGrowth = clamp(targetGrowth + 0.1, 0, 1.08);
    windTarget = (Math.random() - 0.5) * 0.5;
    hintEl.textContent = '–î–µ—Ä–µ–≤–æ –≤–ø–∏—Ç–∞–ª–æ –≤–ª–∞–≥—É –∏ —Ç—è–Ω–µ—Ç—Å—è –±—ã—Å—Ç—Ä–µ–µ.';
  });

  canvas.addEventListener('pointerdown', (evt) => {
    if (evt.button !== 0) return;
    const point = pointerToCanvas(evt);
    sawState.active = true;
    updatePointer(point);
    performSawCut();
  });

  canvas.addEventListener('pointermove', (evt) => {
    const point = pointerToCanvas(evt);
    updatePointer(point);
    if (sawState.active) {
      performSawCut();
    }
  });

  window.addEventListener('pointerup', () => {
    sawState.active = false;
  });

  canvas.addEventListener('pointerleave', () => {
    sawState.active = false;
  });

  canvas.addEventListener('contextmenu', (evt) => evt.preventDefault());

  function loop(time) {
    deltaMs = time - lastTime || 16;
    deltaMs = Math.min(Math.max(deltaMs, 8), 120);
    lastTime = time;
    fps = fps * 0.9 + Math.min(120, 1000 / deltaMs) * 0.1;

    const lerpFactor = clamp(deltaMs * CONFIG.baseGrowthSpeed, 0, 0.04);
    growth += (targetGrowth - growth) * lerpFactor;
    growth = clamp(growth, 0, 1.08);

    hydration = Math.max(0, hydration - deltaMs * 0.00022);
    if (hydration > 0.001) {
      targetGrowth = clamp(targetGrowth + hydration * 0.0005, 0, 1.08);
    }

    wind += (windTarget - wind) * clamp(deltaMs * 0.0006, 0, 1);
    if (Math.random() < 0.002) {
      windTarget = (Math.random() - 0.5) * (0.4 + 0.3 * (1 - growth));
    }

    season += deltaMs * 0.000015;
    stageTimer += deltaMs;
    simulatedAge += deltaMs * 0.00005;

    updateLifeStage(deltaMs);
    updateFireflies(deltaMs);
    updateClouds(deltaMs);
    updateBirds(deltaMs);
    updateSaplings(deltaMs);
    updateSawdust(deltaMs);
    updateSawTrail(deltaMs);
    updateWeather(deltaMs);
    updateInsects(deltaMs);
    updateWorms(deltaMs);

    ctx.clearRect(0, 0, width, height);
    drawSky(time);
    drawMountains(time);
    drawCloudsLayer();
    drawRain();
    drawFirefliesLayer();
    drawBirdsLayer(time);
    drawGround();
    drawSaplings(time);
    drawTree(time);
    drawBirdOnTree(time);
    drawInsects(time);
    drawWorms(time);
    drawSawOverlay();

    updateHud();

    requestAnimationFrame(loop);
  }

  scheduleGrowthPulse();
  requestAnimationFrame(loop);
})();
  </script>

</body>
</html>
